server {
    listen 80;
    server_name localhost;

    # DNS resolver for Docker network; disable IPv6 to avoid warnings.
    resolver 127.0.0.11 ipv6=off;

    # Static files volume mounted by the simulator.
    root /opt/cf-auth-sim/html;

    # Common proxy headers and behaviour.
    proxy_http_version 1.1;
    proxy_buffering off;
    proxy_set_header X-Amz-Cf-Id $request_id;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    # Export selected environment variables into nginx variables using Lua.
    set_by_lua_block $ENV_DEBUG_PAGE_NO_AUTH { return ENV_DEBUG_PAGE_NO_AUTH }
    set_by_lua_block $ENV_KC_REALM_NAME { return ENV_KC_REALM_NAME }
    set_by_lua_block $ENV_KC_CLIENT_ID { return ENV_KC_CLIENT_ID }
    set_by_lua_block $ENV_KC_CLIENT_SECRET { return ENV_KC_CLIENT_SECRET }
    set_by_lua_block $ENV_KC_CF_SIGN_KEY_ID { return ENV_KC_CF_SIGN_KEY_ID }
    set_by_lua_block $ENV_KC_URL { return ENV_KC_URL }
    set_by_lua_block $ENV_KC_INTERNAL_URL { return ENV_KC_INTERNAL_URL }
    set_by_lua_block $ENV_APP_URL { return ENV_APP_URL }

    # Extract host[:port] from ENV_KC_URL for the Host header when proxying.
    set_by_lua_block $kc_host {
        if ENV_KC_URL then
            return ENV_KC_URL:match("^https?://([^/]+)")
        end
        return nil
    }

    # Logout entry: clear CloudFront signed cookie trio and redirect to /.
    location /logout {
        add_header Set-Cookie "CloudFront-Policy=; Path=/; HttpOnly; Max-Age=0";
        add_header Set-Cookie "CloudFront-Signature=; Path=/; HttpOnly; Max-Age=0";
        add_header Set-Cookie "CloudFront-Key-Pair-Id=; Path=/; HttpOnly; Max-Age=0";
        return 302 $scheme://$http_host/;
    }

    # Main entry point. Renders app or triggers Keycloak flow depending on auth.
    location / {
        default_type text/html;

        access_by_lua_block {
            local check_auth_result = cloudfront_auth.check_auth()

            -- If a POST includes redirect-to-keycloak=1, forward to Keycloak.
            if ngx.req.get_method() == "POST" then
                ngx.req.read_body()
                local args, err = ngx.req.get_post_args()
                if args and args["redirect-to-keycloak"] == "1" then
                    ngx.req.set_uri("/cloudfront-auth/.cdn-auth/_cf_redirect_403")
                    return ngx.exec("@keycloak_proxy")
                end
            elseif check_auth_result.is_authenticated and ENV_APP_URL then
                -- Authenticated: proxy to the upstream app.
                return ngx.exec("@app_proxy")
            elseif not check_auth_result.is_authenticated and
                   (ENV_DEBUG_PAGE_NO_AUTH == "never" or
                    (ENV_DEBUG_PAGE_NO_AUTH == "on_error" and
                     check_auth_result.auth_status == "warning"))
            then
                -- Not authenticated: initiate Keycloak redirect flow.
                ngx.req.set_uri("/cloudfront-auth/.cdn-auth/_cf_redirect_403")
                return ngx.exec("@keycloak_proxy_403")
            else
                -- Render local debug/index page with auth info.
                resty_template.render("index.html", check_auth_result)
            end
        }
    }

    # Transparent proxy for paths under /.cdn-auth/ to the Keycloak proxy.
    location ~ ^/.cdn-auth/ {
        rewrite ^/.cdn-auth/(.*) /cloudfront-auth/.cdn-auth/$1 break;
        access_by_lua_block { ngx.exec("@keycloak_proxy") }
    }

    # Internal location that forwards requests to Keycloak.
    location @keycloak_proxy {
        internal;
        include /opt/cf-auth-sim/nginx.conf.d/keycloak-proxy-common.inc;
    }

    # Internal location that forwards requests to Keycloak with 403 status.
    location @keycloak_proxy_403 {
        internal;

        # Override status code to 403 while keeping proxy content (CloudFront behavior)
        header_filter_by_lua_block {
            ngx.status = 403
        }

        include /opt/cf-auth-sim/nginx.conf.d/keycloak-proxy-common.inc;
    }

    # Internal proxy to the application upstream when authenticated.
    location @app_proxy {
        internal;
        proxy_pass $ENV_APP_URL;
    }

    # Serve a dynamic error page generated by the Lua module.
    location @keycloak_error {
        internal;
        content_by_lua_block {
            local error_pages = require "error_pages"
            local error_code = ngx.var.status or "502"
            error_pages.serve_error_page(error_code, nil)
        }
    }

    # Fallback static error page for common server errors.
    error_page 500 502 503 504 /50X.html;

    location = /50X.html {
        root /opt/cf-auth-sim/html;
        internal;
    }
}